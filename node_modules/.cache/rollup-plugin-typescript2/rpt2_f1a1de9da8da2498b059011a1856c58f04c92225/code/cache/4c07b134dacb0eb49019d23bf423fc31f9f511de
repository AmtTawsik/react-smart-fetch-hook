{"code":"import { __awaiter } from \"tslib\";\nimport { useState, useEffect, useCallback, useRef } from \"react\";\nexport function useSmartFetch(url, options = {}) {\n    const { cacheKey, retry = 0, refetchOnMount = true, refreshInterval = 0, cacheExpiry, timeout = 5000, deps = [], initialData = null, } = options;\n    const [data, setData] = useState(initialData);\n    const [error, setError] = useState(null);\n    const [loading, setLoading] = useState(false);\n    const abortControllerRef = useRef(null);\n    const fetchData = useCallback(() => __awaiter(this, void 0, void 0, function* () {\n        var _a;\n        (_a = abortControllerRef.current) === null || _a === void 0 ? void 0 : _a.abort();\n        abortControllerRef.current = new AbortController();\n        setLoading(true);\n        setError(null);\n        let attempt = 0;\n        let success = false;\n        while (attempt <= retry && !success) {\n            try {\n                const timer = setTimeout(() => { var _a; return (_a = abortControllerRef.current) === null || _a === void 0 ? void 0 : _a.abort(); }, timeout);\n                const res = yield fetch(url, {\n                    signal: abortControllerRef.current.signal,\n                });\n                clearTimeout(timer);\n                if (!res.ok)\n                    throw new Error(`HTTP ${res.status}`);\n                const json = yield res.json();\n                if (cacheKey) {\n                    const cacheData = {\n                        data: json,\n                        timestamp: Date.now(),\n                    };\n                    localStorage.setItem(cacheKey, JSON.stringify(cacheData));\n                }\n                setData(json);\n                success = true;\n            }\n            catch (err) {\n                attempt++;\n                if (attempt > retry) {\n                    setError(err);\n                }\n            }\n        }\n        setLoading(false);\n    }), [url, retry, cacheKey, timeout]);\n    // Cache handling with expiry\n    useEffect(() => {\n        if (cacheKey) {\n            const cached = localStorage.getItem(cacheKey);\n            if (cached) {\n                const { data, timestamp } = JSON.parse(cached);\n                const isExpired = cacheExpiry && Date.now() - timestamp > cacheExpiry * 1000;\n                if (!isExpired)\n                    setData(data);\n            }\n        }\n    }, [cacheKey, cacheExpiry]);\n    // Initial fetch and refresh interval\n    useEffect(() => {\n        if (refetchOnMount)\n            fetchData();\n        let intervalId;\n        if (refreshInterval > 0) {\n            intervalId = setInterval(fetchData, refreshInterval);\n        }\n        return () => {\n            var _a;\n            (_a = abortControllerRef.current) === null || _a === void 0 ? void 0 : _a.abort();\n            clearInterval(intervalId);\n        };\n    }, [fetchData, refreshInterval, ...deps]);\n    return { data, error, loading, refetch: fetchData };\n}\n","references":["D:/Packages/react-smart-fetch-hook/node_modules/@types/react/index.d.ts"],"dts":{"name":"D:/Packages/react-smart-fetch-hook/node_modules/.cache/rollup-plugin-typescript2/placeholder/useSmartFetch.d.ts","writeByteOrderMark":false,"text":"interface UseSmartFetchOptions<T> {\n    cacheKey?: string;\n    retry?: number;\n    refetchOnMount?: boolean;\n    refreshInterval?: number;\n    cacheExpiry?: number;\n    timeout?: number;\n    deps?: any[];\n    initialData?: T;\n}\nexport declare function useSmartFetch<T = unknown>(url: string, options?: UseSmartFetchOptions<T>): {\n    data: T | null;\n    error: Error | null;\n    loading: boolean;\n    refetch: () => Promise<void>;\n};\nexport {};\n"}}
